% !TEX program = lualatex
\documentclass[11pt,a4paper,french]{article}
\usepackage{rayanlib}

\def\authorvar{Rayan Drissi, Emre Ulusoy, Marc Guillemot, Charlie Chaplin}
\def\classevar{ING3}
\def\anneevar{2025}

\begin{document}

\stylizeDocSpe{GPGPU}{Projet IRGPU}{Détection de mouvement}{Calcul sur GPU}

\section{Introduction}

Ce rapport présente notre implémentation d'un système de détection de mouvement en temps réel utilisant le GPU. L'objectif est de traiter un flux vidéo via GStreamer et d'identifier les zones en mouvement par soustraction de fond.

\subsection{Contexte}

La détection de mouvement est une tâche fondamentale en vision par ordinateur. Elle consiste à identifier les pixels qui diffèrent significativement d'un modèle de fond estimé. Cette opération est particulièrement adaptée au parallélisme massif offert par les GPU.

\subsection{Pipeline de traitement}

Notre pipeline se compose de 4 étapes principales :

\begin{enumerate}
    \item \textbf{Estimation du fond} : Weighted Reservoir Sampling
    \item \textbf{Masque de mouvement} : Différence RGB avec le fond
    \item \textbf{Filtrage morphologique} : Ouverture (érosion + dilatation)
    \item \textbf{Hystérésis} : Double seuillage avec reconstruction
\end{enumerate}

\section{Configuration matérielle}

\subsection{Environnement d'exécution}

Les tests ont été réalisés sous \textbf{WSL2} (Windows Subsystem for Linux 2) avec Ubuntu 22.04.5 LTS. Cette configuration permet d'accéder au GPU NVIDIA via le driver WSL avec support CUDA complet.

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Composant} & \textbf{Spécifications} \\
\hline
\textbf{Système} & WSL2 - Ubuntu 22.04.5 LTS \\
\textbf{Kernel} & 5.15.167.4-microsoft-standard-WSL2 \\
\hline
\end{tabular}
\end{center}

\subsection{Processeur (CPU)}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Modèle} & AMD Ryzen 9 5950X \\
\textbf{Architecture} & Zen 3 (7nm) \\
\textbf{Cœurs / Threads} & 16 / 32 \\
\textbf{Fréquence base/boost} & 3.4 GHz / 4.9 GHz \\
\textbf{Cache L3} & 64 Mo \\
\textbf{TDP} & 105W \\
\hline
\end{tabular}
\end{center}

\subsection{Mémoire (RAM)}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Capacité} & 64 Go (58 Go disponibles sous WSL2) \\
\textbf{Type} & DDR4 \\
\textbf{Fréquence} & 3600 MHz \\
\textbf{Latence} & CL16-18-18 \\
\hline
\end{tabular}
\end{center}

\subsection{Carte graphique (GPU)}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Modèle} & NVIDIA GeForce RTX 5060 \\
\textbf{Architecture} & Blackwell \\
\textbf{VRAM} & 8 Go GDDR7 \\
\textbf{Compute Capability} & 12.0 \\
\textbf{CUDA Version} & 13.0 \\
\textbf{Driver} & 581.80 \\
\hline
\end{tabular}
\end{center}

\section{Choix d'implémentation}

\subsection{Estimation du fond}

\begin{definition*}{Weighted Reservoir Sampling}{}
Pour chaque pixel, on maintient $k=4$ réservoirs contenant une couleur RGB et un poids. Lors de l'échantillonnage :
\begin{itemize}
    \item Si un réservoir correspond (distance RGB $< 30$), on incrémente son poids
    \item Sinon, on remplace le réservoir de poids minimal avec probabilité inversement proportionnelle à son poids
\end{itemize}
Le fond est la couleur du réservoir de poids maximal.
\end{definition*}

\textbf{Pourquoi ce choix ?} Cette méthode s'adapte naturellement aux scènes avec plusieurs fonds alternés (ex: feuilles qui bougent) contrairement à une simple moyenne mobile.

\subsection{Morphologie}

L'ouverture morphologique (érosion puis dilatation) permet d'éliminer le bruit tout en préservant les grandes régions. Nous utilisons un \textbf{élément structurant en forme de disque} pour éviter les artefacts directionnels.

\subsection{Hystérésis}

\begin{definition*}{Double seuillage avec reconstruction}{}
\begin{enumerate}
    \item Les pixels avec score $> T_{high}$ sont marqués comme mouvement certain
    \item Les pixels avec score $> T_{low}$ connectés à un pixel certain sont également marqués
    \item Itération jusqu'à convergence
\end{enumerate}
\end{definition*}

\section{Implémentation GPU}

\subsection{Kernels CUDA}

Tous les traitements sont implémentés en CUDA :

\begin{itemize}
    \item \texttt{background\_estimation\_kernel} : Mise à jour des réservoirs avec cuRAND
    \item \texttt{motion\_mask\_kernel} : Calcul de la différence RGB
    \item \texttt{erosion\_kernel} / \texttt{dilation\_kernel} : Morphologie avec élément disque
    \item \texttt{hysteresis\_reconstruction\_kernel} : Propagation itérative avec flag atomique
    \item \texttt{visualization\_kernel} : Overlay rouge sur les zones en mouvement
\end{itemize}

\subsection{Optimisation clé : Hystérésis GPU}

L'optimisation majeure a été le portage de l'hystérésis sur GPU. La version initiale effectuait :

\begin{enumerate}
    \item Copie GPU $\rightarrow$ CPU (\texttt{cudaMemcpy2D})
    \item Boucle d'hystérésis sur CPU (jusqu'à 100 itérations)
    \item Copie CPU $\rightarrow$ GPU (\texttt{cudaMemcpy2D})
\end{enumerate}

La version optimisée utilise un kernel itératif avec un flag atomique (\texttt{atomicOr}) pour détecter la convergence, éliminant les transferts mémoire coûteux.

\section{Benchmarks et analyse}

\subsection{Résultats CPU vs GPU (version finale)}

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Vidéo} & \textbf{CPU (s)} & \textbf{GPU v1.5 (s)} & \textbf{Speedup} \\
\hline
ACET.mp4 & 13.19 & 5.32 & \textbf{2.5$\times$} \\
lil\_clown\_studio.mp4 & 40.62 & 7.96 & \textbf{5.1$\times$} \\
1023-142621257\_large.mp4 & 72.27 & 12.02 & \textbf{6.0$\times$} \\
27999-366978301\_large.mp4 & 37.60 & 7.66 & \textbf{4.9$\times$} \\
3630-172488409\_large.mp4 & 64.26 & 8.55 & \textbf{7.5$\times$} \\
6387-191695740\_large.mp4 & 69.01 & 10.22 & \textbf{6.8$\times$} \\
20895-313083562\_large.mp4 & 164.57 & 20.99 & \textbf{7.8$\times$} \\
\hline
\multicolumn{3}{|r|}{\textbf{Speedup moyen}} & \textbf{5.8$\times$} \\
\hline
\end{tabular}
\end{center}

\subsection{Évolution des performances par version}

\begin{center}
\small
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Vidéo} & \textbf{v1.0} & \textbf{v1.1} & \textbf{v1.2} & \textbf{v1.3} & \textbf{v1.4} & \textbf{v1.5} \\
\hline
ACET & 6.26 & 5.24 & 5.23 & 6.26 & 6.41 & \textbf{5.32} \\
lil\_clown & 28.70 & 9.49 & 10.09 & 10.31 & 9.36 & \textbf{7.96} \\
1023 & 61.09 & \textbf{9.52} & 12.21 & 9.37 & 10.05 & 12.02 \\
27999 & 33.62 & 7.37 & \textbf{5.43} & 7.36 & 7.76 & 7.66 \\
3630 & 51.81 & 11.09 & 10.94 & 11.16 & 11.37 & \textbf{8.55} \\
6387 & 63.80 & 8.78 & 10.85 & 8.46 & \textbf{8.12} & 10.22 \\
20895 & 142.12 & 23.21 & 21.66 & 23.05 & 23.20 & \textbf{20.99} \\
\hline
\end{tabular}
\end{center}

\textit{Note : Les valeurs en gras indiquent la meilleure performance pour chaque vidéo.}

\subsection{Impact des optimisations}

\begin{center}
\begin{tabular}{|l|l|c|l|}
\hline
\textbf{Version} & \textbf{Optimisation} & \textbf{Impact} & \textbf{Explication} \\
\hline
v1.0 $\rightarrow$ v1.1 & Hystérésis GPU & \textbf{+375\%} & Élimination transferts CPU$\leftrightarrow$GPU \\
v1.1 $\rightarrow$ v1.2 & Sans cudaDeviceSync & $-3.4\%$ & Déjà pipeliné par le driver \\
v1.2 $\rightarrow$ v1.3 & Shared memory & $-2.9\%$ & Rayon trop petit (3px) \\
v1.3 $\rightarrow$ v1.4 & Fusion kernels & $-0.6\%$ & Cache L2 déjà efficace \\
\hline
\end{tabular}
\end{center}

\subsection{Graphique comparatif CPU vs GPU}

\begin{center}
\begin{tikzpicture}
\begin{axis}[
    ybar,
    bar width=10pt,
    width=0.95\textwidth,
    height=8cm,
    ylabel={Temps (s)},
    symbolic x coords={ACET, lil\_clown, 1023, 27999, 3630, 6387, 20895},
    xtick=data,
    x tick label style={rotate=45, anchor=east, font=\small},
    legend style={at={(0.5,-0.3)}, anchor=north, legend columns=2},
    ymin=0,
    ymax=180,
    nodes near coords,
    nodes near coords style={font=\tiny},
    every node near coord/.append style={rotate=90, anchor=west},
]
\addplot[fill=main1!70] coordinates {
    (ACET, 13.19)
    (lil\_clown, 40.62)
    (1023, 72.27)
    (27999, 37.60)
    (3630, 64.26)
    (6387, 69.01)
    (20895, 164.57)
};
\addplot[fill=main3!70] coordinates {
    (ACET, 5.32)
    (lil\_clown, 7.96)
    (1023, 12.02)
    (27999, 7.66)
    (3630, 8.55)
    (6387, 10.22)
    (20895, 20.99)
};
\legend{CPU (Ryzen 9 5950X), GPU (RTX 5060)}
\end{axis}
\end{tikzpicture}
\end{center}

\subsection{Analyse des résultats}

\begin{property*}{Observation clé}{}
Le speedup augmente avec la taille de la vidéo : de 2.5$\times$ pour ACET (courte) à 7.8$\times$ pour 20895 (longue). Cela s'explique par l'amortissement du coût d'initialisation CUDA sur plus de frames.
\end{property*}

\textbf{Pourquoi les optimisations v1.2-v1.4 n'ont pas d'impact ?}

\begin{enumerate}
    \item \textbf{cudaDeviceSynchronize()} : Le driver CUDA optimise déjà le pipelining des kernels dans le même stream. Les supprimer n'apporte pas de gain mesurable.
    
    \item \textbf{Shared memory} : L'élément structurant a un rayon de 3 pixels. Le ratio surface/périmètre est trop faible pour amortir le coût du chargement du halo en shared memory.
    
    \item \textbf{Fusion de kernels} : Le cache L2 du GPU (8 Mo sur RTX 5060) conserve déjà les données entre kernels successifs, rendant la fusion inutile.
\end{enumerate}

\subsection{Bottleneck actuel}

Le bottleneck principal est le \textbf{transfert Host$\leftrightarrow$Device} à chaque frame :

\begin{itemize}
    \item \texttt{cudaMemcpy2D} pour copier l'image d'entrée vers le GPU
    \item \texttt{cudaMemcpy2D} pour copier le résultat vers le CPU
\end{itemize}

Pour une image 1920$\times$1080 RGB : $1920 \times 1080 \times 3 = 6.2$ Mo par transfert, soit 12.4 Mo par frame aller-retour.

\section{Conclusion}

Nous avons implémenté un système de détection de mouvement atteignant un speedup moyen de \textbf{5.8$\times$} par rapport à la version CPU sur un Ryzen 9 5950X. L'optimisation clé a été le portage de l'hystérésis sur GPU (v1.1), qui a permis un gain de \textbf{346\%}.

Les optimisations classiques (shared memory, kernel fusion, suppression des synchronisations) n'ont pas apporté de gain significatif car le bottleneck se situe au niveau des transferts mémoire Host$\leftrightarrow$Device.

\textbf{Pistes d'amélioration :}
\begin{itemize}
    \item Utiliser la \textbf{zero-copy memory} pour éviter les copies explicites
    \item Implémenter des \textbf{CUDA streams} pour overlapper transferts et calcul
    \item Garder les données sur le GPU avec des \textbf{persistent kernels}
\end{itemize}

\vfill

\begin{center}
\textit{Projet réalisé dans le cadre du cours GPGPU - EPITA ING3 - 2025}
\end{center}

\end{document}
